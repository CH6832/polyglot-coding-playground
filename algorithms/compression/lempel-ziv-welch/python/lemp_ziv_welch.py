#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""lemp_ziv_welch.py

The Lempel-Ziv-Welch (LZW) algorithm is a lossless data compression algorithm that works by replacing sequences of characters with single codes. It was developed by Abraham Lempel, Jacob Ziv, and Terry Welch in the 1970s and became widely used in various applications.

Here's a general overview of how the LZW algorithm works:

    Dictionary Initialization: The algorithm starts with a dictionary containing all possible characters (e.g., ASCII characters) as keys, each mapped to its corresponding code. Additionally, there is a special code reserved for clearing the dictionary and resetting it to its initial state.

    Compression:
        The algorithm reads the input data one character at a time.
        It maintains a current string initialized as the empty string.
        For each character read from the input:
            Append the character to the current string, forming a new string.
            Check if the new string is present in the dictionary:
                If the new string is in the dictionary, update the current string to include the new character and continue reading the input.
                If the new string is not in the dictionary:
                    Output the code corresponding to the current string (the longest string in the dictionary that is a prefix of the new string).
                    Add the new string to the dictionary and assign it the next available code.
                    Update the current string to contain only the last character read.
        Repeat the process until all input characters are processed.

    Decompression:
        The algorithm maintains a dictionary similar to the one used in compression.
        It reads the list of codes generated by the compression step.
        It initializes a current string with the character corresponding to the first code.
        For each code in the list:
            If the code is not in the dictionary, use the current string followed by its first character as the new string.
            If the code is in the dictionary, get the corresponding string.
            Output the string and add a new entry to the dictionary for the current string followed by the first character of the new string.
            Update the current string to the new string.
        Repeat the process until all codes are processed.

    Dictionary Management:
        The dictionary is dynamically updated during compression and decompression.
        In compression, new strings encountered are added to the dictionary along with their corresponding codes.
        In decompression, new entries are added to the dictionary as needed to ensure that all codes can be properly decoded.

This implementation includes functions for compressing and decompressing data
using the LZW algorithm. The compress function takes a string as input and returns
a list of integers representing the compressed data. The decompress function
takes a list of integers (compressed data) as input and returns the decompressed
string.

.. _PEP 0000:
    https://peps.python.org/pep-0000/
"""


from sys import maxsize
from itertools import permutations
from typing import List

V = 4


def main() -> None:
    """Driving code and main function"""
    # Example usage
    input_data = "ABABABA"
    compressed_data = compress(input_data)
    print("Compressed:", compressed_data)
    decompressed_data = decompress(compressed_data)
    print("Decompressed:", decompressed_data)
 
    return None


def compress(data):
    # Build the dictionary
    dictionary = {chr(i): i for i in range(256)}
    next_code = 256
    result = []

    # Initialize variables
    current_string = ""
    for char in data:
        # Add the current character to the current string
        new_string = current_string + char
        # If the new string is in the dictionary, update the current string
        if new_string in dictionary:
            current_string = new_string
        # If the new string is not in the dictionary, add the code for the current string to the result
        else:
            result.append(dictionary[current_string])
            # Add the new string to the dictionary
            dictionary[new_string] = next_code
            next_code += 1
            # Reset the current string
            current_string = char

    # Add the last code to the result
    if current_string:
        result.append(dictionary[current_string])

    return result


def decompress(compressed_data):
    # Build the dictionary
    dictionary = {i: chr(i) for i in range(256)}
    next_code = 256
    result = []

    # Initialize variables
    current_string = chr(compressed_data.pop(0))
    result.append(current_string)

    for code in compressed_data:
        # If the code is not in the dictionary, use the current string followed by its first character
        if code not in dictionary:
            new_string = current_string + current_string[0]
        # If the code is in the dictionary, get the corresponding string
        else:
            new_string = dictionary[code]

        # Add the new string to the result
        result.append(new_string)

        # Add the current string followed by the first character of the new string to the dictionary
        dictionary[next_code] = current_string + new_string[0]
        next_code += 1

        # Update the current string
        current_string = new_string

    return ''.join(result)



if __name__ == '__main__':
    main()

